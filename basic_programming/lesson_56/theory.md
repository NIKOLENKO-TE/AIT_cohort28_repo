# Класс `Collections`

Класс `Collections`, как и класс `Math`, в основном содержит **статические** методы и предназначен для работы
с коллекциями - списками и множествами.

Все методы класса описаны в [документации](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collections.html#method-summary).

Примечание: для работы с массивами есть похожий класс [`Arrays`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Arrays.html).

Нас интересуют в первую очередь методы:
- `max(Collection<?> coll)`
- `min(Collection<?> coll)`
- `reverse(List<?> list)`
- `sort(List<T> list)`

Методы `min()` и `max()` работают с любыми коллекциями (см. интерфейс `Collection` ниже) и возвращают
минимальный и максимальный элементы.

Методы `reverse()` и `sort()` работают с любыми списками (интерфейс `List`) и переворачивают или
сортируют список. Изменения происходят "на месте" (*in-place*) - меняется существующий список
(переданный в аргументах), а не создаётся новый.

========================================================

### HashSet - что это такое и для чего это нужно
Set в переводе с английского - это "множество каких-то элементов" в нашем контексте.
Особенность этого множества в том, что оно может **хранить только уникальные значения, элементы**.
**Пример:**
бренды автомобилей - это множество, где каждый элемент должен быть уникален.
Их сейчас порядка 100...

Давайте приведем примеры полезных Set из жизни:
- индексы для почтовых адресов
- VIN автомобилей
- серийный номер изделия
- буквенный алфавит
- штирх-код
- ссылки в Интернете
- из финансовой сферы:
- ... (приведите свой пример)

Вопрос: Как ведет себя Set при попытке добавить в него имеющийся уже в нем элемент?
Ответ: игнорирует эту операцию.

Давайте это проверим...
**Задача 1:** Сформировать HashSet из букв латинского алфавита, попытаться добавить в это множество
уже существующую букву, проверить, что будет происходить...
[Полезная ссылка на таблицу кодов]( Полезная ссылка https://xn----7sbbaqhlkm9ah9aiq.net/news-new/kodi-ascii-simvolov.html)
**_Синтаксис для инициализации HashSet:_**
HashSet<Type> myHashSet = new HashSet<Type>();

**Задача 2:** Написать приложение, которое позволит понять,
из каких мест на данную почту приходят письма.

### Как вычисляется Hash ???
Метод hashCode() – возвращает хэш-код для данной строки (набор символов).
Хэш-значение пустой строки равно нулю.
hashCode(строка) = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1], ^ - это возведение в степень
s[0] - это 1-й элемент строки, s[1] - 2-й элемент и т.д.
Простое число 31 подобрано опытным путем

### Для чего нужен Hash? Откуда он взялся?
Hash - это ключ (уникальный идентификатор) для hash-таблицы, в которой хранятся
пары значений:
hash 1-го элемента | 1-й элемент множества
hash 2-го элемента | 2-й элемент множества
...

### Еще раз про HashSet (summary)
1. Принципиальная невозможность повторений элементов множества (коллекции);
2. Нет порядка, при добавлении имеющегося элемент попадает куда-то внутрь множества
   (ПРОВЕРИТЬ самостоятельно на почтовых индексах);
3. Нет индексов элементов, у каждого элемента есть Hash, по которому он и определяется (находится).


========================================================

### HashMap - что это такое и для чего это нужно?

Внутри структуры/коллекции Map (Dictionary) данные хранятся в формате “ключ”-”значение”, то есть по парам.
И в качестве ключей, и в качестве значений могут выступать любые типы
— числа, строки или даже объекты других классов (это на будущее).
ВНИМАНИЕ!!! Ключ должен быть **уникален**!

А при чем здесь Hash?
Hash вычисляется для ключа и храниться в Hash-таблице.
Внутри себя HashMap хранит элементы в таблице вида:
Hash (ключа) | Значение
Hash (ключа) | Значение
...
Вычисление хеша ключа **обеспечивает гарантированную скорость доступа к элементу** (паре значений) в коллекции.
Вероятность, что хеши ключей совпадут очень мала, но все же есть.
Такая ситуация называется **коллизией**. Эту ситуацию HashMap берет на себя, создавая связанный список.
При этом в HashMap могут быть два и более совпадающих по значению (но не по ключу!)элементов коллекции.

**Примеры ПОЛЕЗНЫХ ПАР КЛЮЧ - ЗНАЧЕНИЕ:**
ФИО                       , возраст
госномер                  , марка автомобиля
адрес                     , юридическое лицо (наименование)
BIC                       , IBAN
SWIFT code                , страна (банк)
телефонный номер          , контакт
код страны (телефонный)   , страна
...

#### Операции с элементами HashMap
nameHashMap.put ( key , value) - добавление и **обновление** элемента
nameHashMap.get ( key ) - получение значения по ключу
nameHashMap.remove ( key ) - удаление значения по ключу
nameHashMap.size () - получение размера коллекции элементов

#### Цикл по элементам HashMap
// Print keys - проход по всем ключам
for (String i : nameHashMap.keySet()) {
System.out.println(i);
}

// Print values - проход по всем значениям
for (String i : nameHashMap.values()) {
System.out.println(i);
}

// Print keys and values - проход по всем ключам и их значениям
for (String i : nameHashMap.keySet()) {
System.out.println("key: " + i + " value: " + nameHashMap.get(i));
}

Номерных индексов, как в массивах или списках, в HashMap нет — доступ к элементу
коллекции осуществляется по **ключу** (напоминаю, что он должен быть уникальным).

#### Синтаксис создания новой HashMap
    HashMap<keyType, valueType> nameHashMap = new HashMap<keyType, valueType>();