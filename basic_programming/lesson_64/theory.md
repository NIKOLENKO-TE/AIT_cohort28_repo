<ol>
<li> В пакете java.util.concurrent есть интерфейс Lock и его имплементация ReentrantLock. Объект этого класса имеет "прямую" связь с mutex. Методы lock, unlock, позволяю блокировать и разблокировать критическую секцию. Стандартный паттерн использования объектов типа Lock, это перед блоком try вызвать метод lock(), а в блоке finally вызвать unlock().
</li>
<li> Интерфейс ReadWriteLock и его имплементация ReentrantReadWriteLock, позволяют реализовать паттерн read-write lock, в Java. Суть патерна, чтобы операции чтения (не меняющие общий объект) из критической секции проходили в параллелном режиме, а операции записи (меняющие общий объект) в эксклюзивном режиме. Для реализации этого патерна надо создать объект ReentrantReadWriteLock и при помощи его методов readLock() и writeLock() ролучить ссылки на соответсвующие Lock.
</li>
<li> В многопоточном программировании создание тредов и переключение контекста являются достаточно "тяжелыми" операциями. Поэтому создание большого колличества тредов, приводит к потере производительности как за счет их создания, так и за счет частого переключения контекста.
</li>
<li> В пакете java.util.concurrent повилась возможность создавать тред пулы. Т. е набор и определенного колличества готов тредов, которым можно передавать для выполнения необходимые задачи. Для хранения ссылки на тред пул предназначен интерфейс ExecutorService. Создания тред пулов происходит при помощи вызовов статических методов у класса Executors. Например Executors.newFixedThreadPool(4) создает тред пул на 4 треда.
</li>
<li> <li> В пакете java.util.concurrent повилась возможность создавать тред пулы. Т. е набор и определенного колличества готов тредов, которым можно передавать для выполнения необходимые задачи. Для хранения ссылки на тред пул предназначен интерфейс ExecutorService. Создания тред пулов происходит при помощи вызовов статических методов у класса Executors. Например Executors.newFixedThreadPool(4) создает тред пул на 4 треда.
</li>При помощи вызова метода execute(Runnable task) у ExecutorService можно передать в тред пул очередную задачу. Метод shutdown() запрещает передачу новых задач в ExecutorService для тред пула. Метод awaitTermination позволяет дождаться завершения выполнения всех задач в тред пуле (это аналог join в тредах).
</li>
<li> Подробнее смотрите в презентации.
</li>
</ol>